<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>glin</title>

  
  <meta name="author" content="lin">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="glin"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="glin" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">glin</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/05/17/ngrok搭建和使用/"><span>ngrok搭建和使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/17/ngrok搭建和使用/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-17T02:23:25.000Z">
          2017-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>&emsp;&emsp;组了个NAS，之前宽带是有外网ip并且段口没有限制，可以很愉快的玩owncloud，以及openvpn到家做更多的事儿。换了个宽带只后虽然还有外网ip，但是并没什么用，端口都不通。所以就想起做个内网穿透，刚好有个梯子VPS（慢死，折腾什么劲）。<br>&emsp;&emsp;其实内网穿透有很多方法</p>
<ul>
<li>ssh隧道：不稳定易断</li>
<li>n2n：访问者需要客户端，或者需要其他工具在vps做一次内部端口转发（没用过）</li>
<li>ngrok、frp等开发内网穿透工具</li>
</ul>
<p>&emsp;&emsp;这次选择ngrok。<br>&emsp;&emsp;ngrok服务端安装在有外网ip的机器上，访问者可以直接访问<br>&emsp;&emsp;ngrok客户端安装在nat后的机器上，这是应用服务的真正提供者。<br>&emsp;&emsp;访问者访问外网主机，外网主机只做请求转发，由内网主机真正提供服务。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>&emsp;&emsp;官方提供的服务是2+，开源的ngrok版本是1.7，并且需要自己编译<br>&emsp;&emsp;ngrok服务端是一台VPS，系统Debian<br>&emsp;&emsp;ngrok客户端是家里的台式机，系统Debian，只需要编译一次ngrok</p>
<h3 id="安装GO"><a href="#安装GO" class="headerlink" title="安装GO"></a>安装GO</h3><p>&emsp;&emsp;使用apt安装的go是1.3版本，在编译中会出现错误，需要手动安装go1.7+，这里的安装过程是参考<a href="https://golang.org/doc/install" target="_blank" rel="external">GO官方文档</a>的</p>
<p>&emsp;&emsp;如果已经使用apt安装了go，需要先卸载<code>apt-get remove golang</code></p>
<ul>
<li><p>下载解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://storage.googleapis.com/golang/go1.7.5.linux-amd64.tar.gz</div><div class="line">tar -C /usr/local -xzf go1.7.5.linux-amd64.tar.gz</div></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量<br>编辑$HOME/.bash_profile 添加 <code>export PATH=$PATH:/usr/local/go/bin</code>，然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source $HOME/.bash_profile</div></pre></td></tr></table></figure>
<p>验证是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go version</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="编译ngrok"><a href="#编译ngrok" class="headerlink" title="编译ngrok"></a>编译ngrok</h3><ul>
<li><p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential mercurial git</div></pre></td></tr></table></figure>
</li>
<li><p>下载源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/inconshreveable/ngrok.git ngrok</div><div class="line">cd ngrok</div></pre></td></tr></table></figure>
</li>
<li><p>生成证书<br>&emsp;&emsp;需要注意的是此处的证书是ngrok上的，意思就是所有经ngrok转发的web使用该证书，无需在转发目标机器的nginx或apach上安装https证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NGROK_DOMAIN=&quot;imququ.com&quot;</div><div class="line"></div><div class="line">openssl genrsa -out base.key 2048</div><div class="line">openssl req -new -x509 -nodes -key base.key -days 10000 -subj &quot;/CN=$NGROK_DOMAIN&quot; -out base.pem</div><div class="line">openssl genrsa -out server.key 2048</div><div class="line">openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csr</div><div class="line">openssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt</div><div class="line"></div><div class="line">cp base.pem assets/client/tls/ngrokroot.crt</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;目前的ngrok版本只能使用x509，另一篇<a href="/2017/05/15/使用acme-tiny获取Let-s-Encrypt免费HTTPS证书/" title="使用Let's Encrypt">使用Let's Encrypt</a>的文章，其中使用的是sha256，不知道怎么统一，所以我将letsencrypt签好的https证书安装在转发目标机器，ngrok直接使用tcp转发，放弃ngrok中的http和https转发。</p>
</li>
<li><p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo make release-server release-client</div></pre></td></tr></table></figure>
<p>ngrok/bin 目录下应该有 ngrok、ngrokd 两个可执行文件，则编译成功。<br>ngrokd是服务端程序，ngrok是客户端程序。</p>
</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul>
<li><p>服务端<br>指定域名、http端口，https端口，以及证书 启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&quot;imququ.com&quot; -httpAddr=&quot;:8081&quot; -httpsAddr=&quot;:8082&quot;</div></pre></td></tr></table></figure>
<p>我不打算使用它的http和https，可以给空字符串以禁用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&quot;imququ.com&quot; -httpAddr=&quot;&quot; -httpsAddr=&quot;&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
<ol>
<li><p>使用http和https<br>写一个简单的配置文件<code>ngrok.cfg</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server_addr: imququ.com:4443</div><div class="line">trust_host_root_certs: false</div><div class="line">inspect_addr: 10.0.0.10:4040</div></pre></td></tr></table></figure>
<p>其中的4443端口是服务端监听客户端接入的端口，可以在启动服务端的时候使用参数<br><code>-tunnelAddr=&quot;:xxx&quot;</code>更改。inspect_addr是监控界面地址，默认为127.0.0.1:4040，这样局域网内其他电脑无法访问只有自己可以访问(Debian系统没装xwindows)，所以可修改为局域网ip或者0.0.0.0。</p>
<p>启动客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#将服务器的http请求转发到本地80端口,即8081-&gt;80转发</div><div class="line">./ngrok -subdomain pub -proto=http -config=ngrok.cfg 80</div><div class="line">#将服务器的https请求转发到本地443端口，即8082-&gt;443转发</div><div class="line">./ngrok -subdomain pub -proto=https -config=ngrok.cfg 443</div></pre></td></tr></table></figure>
<p>这样就可以使用<a href="http://pub.imququ.com，https://pub.imququ.com" target="_blank" rel="external">http://pub.imququ.com，https://pub.imququ.com</a> 访问</p>
</li>
<li><p>使用tcp或其他<br>丰富一下配置文件<code>ngrok.cfg</code>，假设定义了两个tunnel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server_addr: imququ.com:4443</div><div class="line">trust_host_root_certs: false</div><div class="line">inspect_addr: 10.0.0.10:4040</div><div class="line">tunnels:</div><div class="line">    myapp:</div><div class="line">        remote_port: 8087</div><div class="line">        proto:</div><div class="line">            tcp: 80</div><div class="line">    openvpn:</div><div class="line">        remote_port: 1194</div><div class="line">        proto:</div><div class="line">            tcp: 1194</div></pre></td></tr></table></figure>
<p>启动客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#启动myapp，即将服务端8087转发到本地80</div><div class="line">./ngrok -config=ngrok.cfg start myapp</div><div class="line">#启动openvpn，即将服务端1194端口转发到本地1194</div><div class="line">./ngrok -config=ngrok.cfg start openvpn</div></pre></td></tr></table></figure>
<p>支持tcp转发，可玩性比较高。</p>
</li>
</ol>
</li>
</ul>
<h2 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h2><p> &emsp;&emsp;ngrok客户端提供了一个web界面，可以用来监控http和https转发的详细信息，不能监控其他协议转发的内容，比如tcp。监控地址<a href="http://127.0.0.1:4040" target="_blank" rel="external">http://127.0.0.1:4040</a> ，地址可以修改，参考样例客户端配置文件ngrok.cfg</p>
<hr>
<p>最后，慢归慢，但是断了会自动重连，owncloud上传文件还可以接受，毕竟绕了一大圈。</p>
<blockquote>
<p>本文参考链接<a href="https://imququ.com/post/self-hosted-ngrokd.html" target="_blank" rel="external">https://imququ.com/post/self-hosted-ngrokd.html</a></p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ngrok/">ngrok</a><a href="/tags/内网穿透/">内网穿透</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/05/16/html单元格固定宽度/"><span>html单元格固定宽度</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/16/html单元格固定宽度/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-16T05:51:07.000Z">
          2017-05-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>&emsp;&emsp;在页面展示表格的时候，尽可能的会使用固定表格宽度，否则在表格重渲染时(比如翻页)宽度可能发生变化。有时就算定义了宽度，默认的也会根据里面内容的来自动拉伸，造成其他列积压换行。</p>
<p>&emsp;&emsp;通常的做法是：固定表格宽度，溢出内容以省略号代替</p>
<h3 id="表格固定布局"><a href="#表格固定布局" class="headerlink" title="表格固定布局"></a>表格固定布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table&#123;table-layout: fixed;word-break: break-all; word-wrap: break-word;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>table-layout:fixed<br>&emsp;&emsp;列宽由表格宽度和列宽度设定。在固定表格布局中，水平布局仅取决于表格宽度、列宽度、表格边框宽度、单元格间距，而与单元格的内容无关。</p>
</li>
<li><p>word-break:break-all<br>&emsp;&emsp;word-break 属性规定自动换行的处理方法。break-all允许在单词内换行。</p>
</li>
<li><p>word-wrap: break-word<br>&emsp;&emsp;word-wrap 属性允许长单词或 URL 地址换行到下一行。break-word就表示在长单词或 URL 地址内部进行换行。</p>
</li>
</ul>
<p>&emsp;&emsp;其实table-layout, word-break, word-wrap这三个属性都是关于固定宽度显示控制的。<br>对一般的浏览器来说，只需要其中一个就可以完成控制了，但是，一般我们还是会把三个属性都加上，这样以保证对所有的浏览器都兼容</p>
<h3 id="溢出内容省略号"><a href="#溢出内容省略号" class="headerlink" title="溢出内容省略号"></a>溢出内容省略号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.div_context&#123;-o-text-overflow:ellipsis;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;width:100%;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>overflow: hidden<br>&emsp;&emsp;溢出内容隐藏</p>
</li>
<li><p>white-space:nowrap<br>&emsp;&emsp;如何处理元素内的空白，nowrap是文本不会换行，文本会在在同一行上继续，直到遇到 <code>&lt;br&gt;</code> 标签为止，即该元素内部的文本夹杂着换行(空白符)也会在一行展示。</p>
</li>
<li><p>text-overflow:ellipsis<br>&emsp;&emsp;text-overflow 属性规定当文本溢出包含元素时发生的事情，ellipsis显示省略符号来代表被修剪的文本</p>
</li>
<li><p>-o-text-overflow:ellipsis<br>&emsp;&emsp;同上，Opera下的相同效果</p>
</li>
</ul>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><p>&emsp;&emsp;溢出内容省略号替代，需要预览完整信息，可以加上title属性，鼠标停放可展示完整信息（如果自己能开发相应插件就更好了，title提示无法复制，所以只能用在仅展示的场景下）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">        &lt;th align=&quot;left&quot; width=&quot;100&quot;&gt;id&lt;/th&gt;</div><div class="line">        &lt;th align=&quot;left&quot; width=&quot;100&quot;&gt;name&lt;/th&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">        &lt;td align=&quot;left&quot;&gt;12345678&lt;/td&gt;</div><div class="line">        &lt;td align=&quot;left&quot;&gt;&lt;div title=&quot;表格宽度固定多处内容省略号展示&quot; class=&quot;award-name&quot;&gt;表格宽度固定多处内容省略号展示&lt;/div&gt;&lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>本文参考链接<a href="http://www.cnblogs.com/sese/p/6118030.html" target="_blank" rel="external">http://www.cnblogs.com/sese/p/6118030.html</a></p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/html/">html</a><a href="/tags/css/">css</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/05/15/使用acme-tiny获取Let-s-Encrypt免费HTTPS证书/"><span>使用acme-tiny获取Let&#39;s Encrypt免费HTTPS证书</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/15/使用acme-tiny获取Let-s-Encrypt免费HTTPS证书/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-15T09:54:25.000Z">
          2017-05-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>&emsp;&emsp;证书签发服务<a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>提供免费的https证书，但是证书有效期只有90天，因此获取证书后，每90天刷新，获取新证书，官方有提供工具，但是并不好用。第三方的工具也有一大把，个人认为最好用的就是<a href="https://github.com/diafygi/acme-tiny" target="_blank" rel="external">acme-tiny</a>，基于python，几百行的脚本就可以完成获取证书、刷新证书。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>linux系统</li>
<li>安装有python</li>
<li>一个外网可访问的web服务器，apache、nginx，端口必须是80。自己用node或python也可以创建一个简单容器（参考其他文档）</li>
</ul>
<h2 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h2><ul>
<li><p><strong>Stp 1：创建一个账户key</strong><br>&emsp;&emsp;先创建一个文件夹，用来放置生成过程中的各种文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir letsencrypt</div><div class="line">cd letsencrypt</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果以前使用过Let’s Encrypt，保留着<code>account.key</code>，<code>domain.key</code>，<code>domain.csr</code>，只是想刷新域名，请从“Step 3：获取签名证书”开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa 4096 &gt; account.key</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;账户key是用来让Let’s Encrypt识别你的身份的，在以后的刷新证书中需要，代表证书签约者身份</p>
<ul>
<li><strong>Step 2：生成证书签名请求（certificate signing request － CSR）</strong></li>
</ul>
<p>&emsp;&emsp;Let’s Encrypt使用的ACME协议，需要提交一个CSR文件，包括刷新证书，可以使用相同的CSR刷新多次</p>
<ol>
<li><p>创建一个domain-key，不能将账户key用作域名key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa 4096 &gt; domain.key</div></pre></td></tr></table></figure>
</li>
<li><p>生成CSR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#单个域名</div><div class="line">$ openssl req -new -sha256 -key domain.key -subj &quot;/CN=yoursite.com&quot; &gt; domain.csr</div><div class="line">#多个域名</div><div class="line">$ openssl req -new -sha256 -key domain.key -subj &quot;/&quot; -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(printf &quot;[SAN]\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com&quot;)) &gt; domain.csr</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据实际情况以上命令任选其一，Let’s Encrypt的限制，不能使用域名泛解析，并且一个证书最多100个域名。多个域名时，添加的每个域名需要指向同一ip，在后面的验证域名身份时，每个域名都会验证一次</p>
</li>
</ol>
<ul>
<li><strong>Step 3：获取签名证书</strong></li>
</ul>
<ol>
<li><p>搭建临时web服务器<br>&emsp;&emsp;Let’s Encrypt要验证你是不是域名的真正拥有者，在获取证书的过程中，Let’s Encrypt会请求一个类似这样的链接<br><code>http://yoursite.com/.well-known/acme-challenge/xxxxxxxxxxx</code><br>如果链接所指向的文件可访问，则认为域名是你的，当然这个文件内容不是固定的，也是在获取证书的过程中生成的。<br>&emsp;&emsp;因此需要你将域名解析到外网可访问的web服务器上，准确的说是要国外都可以访问，因为Let’s Encrypt服务器是上述地址的访问者，所以国内的主机或者你家里的主机，要确保国外可以访问（如果你的CSR中含有多个域名，每个域名都要解析到该web服务器，因为Let’s Encrypt会把每个域名相应的地址都会访问验证一次，确保你都是域名拥有者）。<br>&emsp;&emsp;假如现有web服务器，最简单的做法就是在web服务器根下创建文件夹 <code>.well-known/acme-challenge/</code>，记住此文件夹的绝对路径，假如是<code>/var/www/html/.well-known/acme-challenge/</code>。<br>&emsp;&emsp;也可以在nginx中配置一个规则，例如，此时的绝对路径为<code>/var/www/challenges/</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#example for nginx</div><div class="line">   server &#123;</div><div class="line">       listen 80;</div><div class="line">       server_name yoursite.com www.yoursite.com;</div><div class="line"></div><div class="line">       location /.well-known/acme-challenge/ &#123;</div><div class="line">           alias /var/www/challenges/;</div><div class="line">           try_files $uri =404;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ...the rest of your config</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获取证书<br>从gitbub下载acme_tiny，其实就是一个python脚本，单文件，放置在当前目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /var/www/html/.well-known/acme-challenge/ &gt; ./signed.crt</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;命令中需要指定<code>account.key</code>，<code>domain.csr</code>，和验证域名文件存放路径<code>--acme-dir</code>设置为上一步创建的文件夹，需要绝对路径。生成的证书文件保存在当前文件夹下，文件名 <code>signed.crt</code><br>&emsp;&emsp;创建域名验证文件和访问域名验证都是在这个命令中一气呵成，所以执行命令的机器和web服务器需在同一主机</p>
</li>
<li><p>合并中间证书</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</div><div class="line">cat signed.crt intermediate.pem &gt; chained.pem</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;chained.pem即是最终的https证书，是最终在应用web容器中配置的证书。</p>
</li>
</ol>
<ul>
<li><p><strong>Step 4：安装证书</strong></p>
<p>&emsp;&emsp;不同的web容器安装方式不同，依nginx为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> server &#123;</div><div class="line">    listen 443;</div><div class="line">    server_name yoursite.com, www.yoursite.com;</div><div class="line"></div><div class="line">    ssl on;</div><div class="line">    ssl_certificate /path/to/chained.pem;</div><div class="line">    ssl_certificate_key /path/to/domain.key;</div><div class="line">    ssl_session_timeout 5m;</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;</div><div class="line">    ssl_session_cache shared:SSL:50m;</div><div class="line">    ssl_dhparam /path/to/server.dhparam;</div><div class="line">    ssl_prefer_server_ciphers on;</div><div class="line"></div><div class="line">    ...the rest of your config</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    server_name yoursite.com, www.yoursite.com;</div><div class="line"></div><div class="line">    location /.well-known/acme-challenge/ &#123;</div><div class="line">        alias /var/www/challenges/;</div><div class="line">        try_files $uri =404;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...the rest of your config</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;刚才的过程中会生成很多文件，需要配置在应用web容器上的其实就<code>chained.pem</code>和<code>domain.key</code>，但是其他文件都有用，<strong>需要保留和备份</strong></p>
</li>
</ul>
<ul>
<li><p><strong>Step 5：刷新证书</strong><br>&emsp;&emsp;证书有效期只有90天，所以在证书快要过期的时候，需要刷新证书，给证书续期。可以写成shell脚本，使用linux的crontab定时执行。<br>&emsp;&emsp;创建shell脚本<code>renew_cert.sh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> #!/usr/bin/sh</div><div class="line">python /path/to/acme_tiny.py --account-key /path/to/account.key --csr /path/to/domain.csr --acme-dir /var/www/html/.well-known/acme-challenge/ &gt; /tmp/signed.crt || exit</div><div class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</div><div class="line">cat /tmp/signed.crt intermediate.pem &gt; /path/to/chained.pem</div><div class="line">service nginx reload</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到以上命令，刷新证书其实就是从获取证书步骤开始再来一遍，需要之前生成的账户key <strong><code>account.key</code></strong>，证书签名请求CSR <strong><code>domain.csr</code></strong>，以及用来验证域名属于你的临时web服务器。当然你可以将你的应用web服务器用作验证域名用的临时服务器。</p>
<p>&emsp;&emsp;创建crontab，例如每月执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 0 1 * * /path/to/renew_cert.sh 2&gt;&gt; /var/log/acme_tiny.log</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;需要注意的地方:<br>&emsp;&emsp;  1.验证域名的challenge文件夹的安全性，不知道和应用服务器放置在一起会有什么问题，期望高人来解答。这也是Let’s Encrypt让人比较头疼的地方，刷新域名仍需验证，而且还要占用80端口。<br>&emsp;&emsp;  2.注意<code>account.key</code>，<code>domain.key</code>的保密和备份<br>&emsp;&emsp;  3.acme-tiny官方给的建议是，刷新脚本用一个特殊的用户，最大的权限是读取<code>account.key</code>、读写challenge文件夹、读写web服务器证书文件的权限（例如/path/to/chained.pem），以及reload web服务器的权限</p>
</li>
</ul>
<blockquote>
<p>本文参考链接<a href="https://github.com/diafygi/acme-tiny" target="_blank" rel="external">https://github.com/diafygi/acme-tiny</a></p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/acme-tiny/">acme-tiny</a><a href="/tags/Let-s-Encrypt/">Let's Encrypt</a><a href="/tags/letsencrypt/">letsencrypt</a><a href="/tags/https证书/">https证书</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/05/15/Git创建空白分支/"><span>Git创建空白分支</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/15/Git创建空白分支/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-15T07:48:37.000Z">
          2017-05-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>&emsp;&emsp;有些情况下，想创建一个从头开始的git分支，例如使用hexo和gitub pages搭建博客，既想将hexo原文件托管在git，又想利用gitub pages。所以我们在xxxx.github.io使用两个分支，master用来发布gitub pages；另一个分支用来托管hexo原文件，两个分支版本毫无关联。另一种场景就是代码重构，需要从头编写。</p>
<ul>
<li><p>下载原仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git@github.com:lilingang/lilingang.github.com.git</div><div class="line">$ cd lilingang.github.com</div></pre></td></tr></table></figure>
</li>
<li><p>创建孤立分支hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout --orphan hexo</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;此时孤立分支在<code>git branch</code>是看不到的，首次commit之后才可以看到</p>
<ul>
<li><p>清空分支内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git rm -rf .</div><div class="line">$ rm .gitignore</div></pre></td></tr></table></figure>
</li>
<li><p>添加新内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;empty branch&quot; &gt;&gt; README.txt</div></pre></td></tr></table></figure>
</li>
<li><p>提交推送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git commit -m &quot;init&quot; .</div><div class="line">$ git push origin hexo</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;commit操作之后，你就可以用<code>git branch</code>命令看到新分支的名字了，然后push到远程仓库，在github页面上即可看到新分支</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/git/">git</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/05/14/hello-world/"><span>Hello World</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/14/hello-world/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-14T12:00:00.000Z">
          2017-05-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/hexo/">hexo</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 lin
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>